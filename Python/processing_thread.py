import numpy as np
from detect_notes import detect_notes
from find_location import find_location
from scipy import signal
from ringbuffer import RingBuffer


def processing_thread(input_audio, player_track, accompaniment_track, update_queue, test_dict):

    # Algorithm initial conditions
    note_detected = False
    note_time = 0
    note_freq = -1
    time = 0
    detected_notes = RingBuffer(10)
    init_zi = True

    # Heinous hack
    Fs = 44100

    # Low pass filter parameters
    filter_cutoff = 30.0
    filter_order = 4

    # Design the filter
    [filter_b, filter_a, ] = signal.bessel(filter_order, [filter_cutoff / (Fs / 2.0)], btype='low', analog=False)

    # Filter initial conditions
    zi_initial = signal.lfilter_zi(filter_b, filter_a)

    # Load the preprocessed notes written by preprocessSong.m
    chunks = np.loadtxt('WriteDir/playerNotes.txt', delimiter='\t', skiprows=1)

    # Make relative chunks (difference in time, ratio in frequency)
    # rel_times = np.diff(chunks[:, 0])
    # rel_freqs = chunks[1:, 1]/chunks[0:-1, 1]
    # rel_chunks = np.c_[rel_times, rel_freqs]

    while True:
        # Get next chunk of data from the input_audio queue
        song_chunk = input_audio.get()

        # Initialize the filter value
        if init_zi:
            zi = zi_initial*song_chunk[0]
            init_zi = False

        # Detect song notes
        test_dict['time'] = time
        time += float(song_chunk.size) / Fs / 2
        id_notes_dict = detect_notes(song_chunk, Fs, filter_b, filter_a, zi, note_detected, note_time, test_dict)

        # Update some of the values from the function
        note_detected = id_notes_dict['note_detected']
        note_time_prev = note_time
        note_time = id_notes_dict['note_time']
        zi = id_notes_dict['zi']
        zi = zi_initial*zi

        # If the note time has changed, a new note was detected, so updated the note_freq
        if note_time is not note_time_prev:
            note_freq_prev = note_freq
            note_freq = id_notes_dict['note_freq']

            note = np.array([[note_time, note_freq]])
            detected_notes.extend(note)

            # Need at least two note detections since we are working with relative frequencies/timings
            if note_freq_prev is not -1:
                # rel_note = np.array([[note_time - note_time_prev, note_freq/note_freq_prev]])
                # print(detected_notes.get())
                # Find chunk location
                # chunk_location = find_location(detected_notes, rel_chunks)
                chunk_location = find_location(detected_notes, chunks)

                # Set position/tempo of the update
                position = chunk_location
                update = OutputUpdate(position, 1.0)
                update_queue.put(update)


class OutputUpdate:
    def __init__(self, position, tempo):
        self.position = position
        self.tempo = tempo
